// 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的
// 房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
//
// 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
//
//
//
// 示例 1：
//
//
// 输入：nums = [2,3,2]
// 输出：3
// 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
//
//
// 示例 2：
//
//
// 输入：nums = [1,2,3,1]
// 输出：4
// 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
//      偷窃到的最高金额 = 1 + 3 = 4 。
//
// 示例 3：
//
//
// 输入：nums = [1,2,3]
// 输出：3
//
//
//
//
// 提示：
//
//
// 1 <= nums.length <= 100
// 0 <= nums[i] <= 1000
//
// Related Topics 数组 动态规划 👍 909 👎 0
package dp_打家劫舍Ⅱ213;

/** @author 燕子豪 */
public class Solution {
  public static void main(String[] args) {
    // 使得dp2[m-1]为最大值的案例
    int[] nums = {1, 1, 3, 6, 7, 10, 7, 1, 8, 5, 9, 1, 4, 4, 3};
    // 使得dp[m-2]为最大值的案例
    //    int[] nums = {10, 3, 5, 7};
    System.out.println(new Solution().rob(nums));
  }

  public int rob(int[] nums) {
    int m = nums.length;
    // 5.边界判断
    if (m == 1) {
      return nums[0];
    } else if (m == 2) {
      return Math.max(nums[0], nums[1]);
    }
    // 1.定义dp数组:dp[i]表示nums数组取到前i个元素,可以打劫到的最多钱(这里先不考虑同时打劫到第一家和最后一家，下面会对这种情况进行单独处理)
    int[] dp = new int[m];
    // 2.初始化值
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    // 3.填充dp数组
    for (int i = 2; i < m; i++) {
      // 4.状态转移方程
      dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
    }

    // 下面是对特殊情况的处理:
    // 如果dp[m-1]==dp[m-2]说明并没有打劫到最后一家,不是特殊情况,可以直接输出结果.(反之打劫到了最后一家,不能直接输出结果)
    if (dp[m - 1] == dp[m - 2]) {
      return dp[m - 1];
    }
    // 特殊情况是同时打劫到第一家和最后一家,下面是对是否打劫到了第一家进行判断(因为打劫到了第二家和最后一家仍然不影响结果可以直接输出)
    int[] dp2 = new int[m];
    // 判断思路是:直接令第一家的钱数为0,然后填充新的dp数组dp2,比较dp2[m-1]与dp[m-1]是否相同,如果相同则说明所打劫的与第一家无关,可以直接输出。
    nums[0] = 0;
    dp[0] = 0;
    dp2[1] = nums[1];

    for (int i = 2; i < m; i++) {
      dp2[i] = Math.max(dp2[i - 2] + nums[i], dp2[i - 1]);
    }
    if (dp[m - 1] == dp2[m - 1]) {
      return dp[m - 1];
    } else {
      // 如果不同,则说明同时打劫了第一家和最后一家,不能直接输出.剩下可能的最大结果只有在dp[m-2]和dp[m-1]中.
      return Math.max(dp[m - 2], dp2[m - 1]);
    }
  }
}
